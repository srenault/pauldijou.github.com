<?xml version='1.0' encoding='utf-8' ?>
<feed xml:lang='en-US' xmlns='http://www.w3.org/2005/Atom'>
  <id>http://pauldijou.fr/</id>
  <title>Paul Dijou Blog</title>
  <updated>2012-08-07T00:00:00Z</updated>
  <link href='http://pauldijou.fr/rss.atom' rel='self' type='application/atom+xml' />
  <link href='http://pauldijou.fr/' rel='alternate' type='text/html' />
  <entry>
    <id>http://pauldijou.fr/blog/2012/08/07/news-richfaces-bootstrap.html</id>
    <title>News about RichFaces Bootstrap</title>
    <updated>2012-08-07T00:00:00Z</updated>
    <published>2012-08-07T00:00:00Z</published>
    <link href='http://pauldijou.fr/blog/2012/08/07/news-richfaces-bootstrap.html' rel='alternate' type='text/html' />
    <summary>
      
English version
Version Française



What&#8217;s new in RichFaces Bootstrap?
Red Alert! The RichFaces Bootstrap project is still under heavy development, tag and attribute names can change at any time and if you find something missing or buggy, there is high chance it&#8217;s not a bug but just hasn&#8217;t been done yet (&#8230; or it&#8217;s a real bug). So only use it for fun and prototype purposes.
Semantic components are a brand new concept. I need to present it first so I can use it when talking next about the new components. Most of the time, for one JSF tag, you have one and only...
    </summary>
    <content type='html'>
      &lt;ul class=&quot;nav nav-tabs&quot;&gt;
&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#2012-08-07-news-richfaces-bootstrap-en&quot; data-toggle=&quot;tab&quot;&gt;English version&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2012-08-07-news-richfaces-bootstrap-fr&quot; data-toggle=&quot;tab&quot;&gt;Version Française&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;tab-content&quot;&gt;
&lt;div class=&quot;tab-pane active&quot; id=&quot;2012-08-07-news-richfaces-bootstrap-en&quot;&gt;
&lt;h3&gt;What&amp;#8217;s new in RichFaces Bootstrap?&lt;/h3&gt;
&lt;div class=&quot;alert alert-error&quot;&gt;&lt;strong&gt;Red Alert!&lt;/strong&gt; The RichFaces Bootstrap project is still under heavy development, tag and attribute names can change at any time and if you find something missing or buggy, there is high chance it&amp;#8217;s not a bug but just hasn&amp;#8217;t been done yet (&amp;#8230; or it&amp;#8217;s a real bug). So only use it for fun and prototype purposes.&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Semantic components&lt;/strong&gt; are a brand new concept. I need to present it first so I can use it when talking next about the new components. Most of the time, for one &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; tag, you have one and only one &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; renderer, it&amp;#8217;s a oneToOne relation (according to &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; naming convention). It seems logical: for one component, you should always have (nearly) the same generated &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; code. But with HTML5, the web is becoming more semantic and that&amp;#8217;s good. Why not have the same with RichFaces? But before we dive into it, what is &amp;#8220;semantic&amp;#8221;? For a real definition see &lt;a href=&quot;http://en.wikipedia.org/wiki/Semantic_Web&quot;&gt;Wikipedia&lt;/a&gt; but here, we will say it&amp;#8217;s when a component serves a global purpose like being a header or a footer but shouldn&amp;#8217;t always render in the same way, instead the rendered result should depend on the context (like a table header isn&amp;#8217;t the same as a column header).&lt;/p&gt;
&lt;p&gt;With RichFaces, a semantic component is a component &lt;strong&gt;with no renderer&lt;/strong&gt;! Yeah yeah, if you use a semantic component on its own, it will throw an exception because it doesn&amp;#8217;t know how to render itself. The concept is that a semantic component will ask its parent in the &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; tree: &amp;#8220;Hey dad, do you know how I can render myself?&amp;#8221;, if it knows, the parent will provide the correct renderer to the semantic component which will render it, otherwise, the semantic component will ask one level higher the same question, and so on until the root element. If no one answers yes to the question, it will throw an exception. That means we also have components that accept semantic components in order to provide them the correct renderer.&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s take a concrete example. The &lt;strong&gt;modal&lt;/strong&gt; component in RichFaces Bootstrap can support 3 semantic components: a header, a body and a footer. You can see that by looking at which interfaces the &lt;code&gt;AbstractModal&lt;/code&gt; implements (see &lt;a href=&quot;https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java#L49&quot;&gt;GitHub&lt;/a&gt;). All interfaces with the syntax &lt;code&gt;Render{1}Capable&lt;/code&gt; are components that support the semantic component &lt;code&gt;{1}&lt;/code&gt;, so here, it&amp;#8217;s &lt;strong&gt;headerFacet&lt;/strong&gt;, &lt;strong&gt;bodyFacet&lt;/strong&gt; and &lt;strong&gt;footerFacet&lt;/strong&gt;. And if you look at the rest of the code of the &lt;code&gt;AbstractModal&lt;/code&gt;, you will see methods with the syntax &lt;code&gt;public String get{1}RendererType()&lt;/code&gt; which are the methods giving the right renderer to use by semantic components. Inside a &lt;strong&gt;modal&lt;/strong&gt;, the &lt;strong&gt;headerFacet&lt;/strong&gt; component will render as a &lt;code&gt;div class=&quot;modal-header&quot;&lt;/code&gt; according to &lt;a href=&quot;https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/templates/org/richfaces/bootstrap/modalHeaderFacet.template.xml&quot;&gt;the renderer provided&lt;/a&gt; by the &lt;strong&gt;modal&lt;/strong&gt;. But inside another component, it could have been totally different &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; code.&lt;/p&gt;
&lt;div class=&quot;alert alert-info&quot;&gt;&lt;strong&gt;Pro tip&lt;/strong&gt; If you take a more accurate look to all current semantic components, you will see that they all follow the same syntax: first their purpose (like &lt;strong&gt;header&lt;/strong&gt; or &lt;strong&gt;footer&lt;/strong&gt;) and then a generic &lt;strong&gt;Facet&lt;/strong&gt; suffix. That give us the full list of semantic components: headerFacet, bodyFacet, footerFacet, menuFacet and positionFacet. Why using a suffix? Because we want to keep the no-suffix name for the real &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; tag. The RichFaces &lt;strong&gt;header&lt;/strong&gt; tag will always generate the &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; &lt;strong&gt;header&lt;/strong&gt; tag like a classic &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; tag (the oneToOne relation) but the &lt;strong&gt;headerFacet&lt;/strong&gt; tag is a semantic component so it can generate anything depending of the context. Also, it makes it easier to see if a RichFaces component is a semantic one or not by just looking at its name.&lt;/div&gt;
&lt;div class=&quot;alert&quot;&gt;&lt;strong&gt;Warning&lt;/strong&gt; Even if the suffix is &lt;strong&gt;Facet&lt;/strong&gt; keep in mind that semantic components &lt;strong&gt;are not facets&lt;/strong&gt;, they don&amp;#8217;t have the same limitations: they have attributes, you can use the same semantic component several time inside the same parent, a semantic component doesn&amp;#8217;t have to be a direct child of a component supporting it and a semantic component can have several children.&lt;/div&gt;
&lt;p&gt;Now, let&amp;#8217;s dive into the new components. &lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com/component/input/&quot;&gt;input&lt;/a&gt; tag is a basic input with all Bootstrap features like prepend and append and several new attributes in order to support new &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; features. By the way, this &lt;strong&gt;input&lt;/strong&gt; centralizes and supports all HTML5 input types, you will no longer need one &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; component for each type, just use the &lt;code&gt;type&lt;/code&gt; attribute (default is &amp;#8220;text&amp;#8221; of course).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com/component/modal/&quot;&gt;modal&lt;/a&gt; is like &lt;code&gt;rich:modalPanel&lt;/code&gt; or &lt;code&gt;rich:popupPanel&lt;/code&gt;, it will display a popup layout on top of your page, potentially covering your page with a dark layer to block any action outside of the modal. The default usage of the modal has a header, specified by using &lt;code&gt;header&lt;/code&gt; attribute or &lt;code&gt;header&lt;/code&gt; facet, a footer specified with &lt;code&gt;footer&lt;/code&gt; facet and a &lt;code&gt;body&lt;/code&gt; which will be the code inside the modal component. Concretely, what&amp;#8217;s happening is that each part, header &amp;#8211; body &amp;#8211; footer, will be wrapped inside a &lt;code&gt;div class=&quot;modal-xxx&quot;&lt;/code&gt; where &amp;#8220;xxx&amp;#8221; is the name of the section in order to align with the Bootstrap syntax. Using footer as a facet might be limiting because you cannot have &lt;strong&gt;a form inside the modal&lt;/strong&gt; wrapping both body and footer because footer, as a facet, will always be outside. The default usage should be &lt;strong&gt;the modal inside the form&lt;/strong&gt; since you will probably not need several forms inside a modal most of the time.&lt;/p&gt;
&lt;p&gt;What if that isn&amp;#8217;t enough? What if you do want the form inside and not outside? Even if this behavior should be enough in most of use-cases, you can still fully customize your modal the way you want! The moment you use one of the following semantic components, headerFacet &amp;#8211; bodyFacet &amp;#8211; footerFacet, it considers you are doing a custom modal and it will not generate the &lt;code&gt;div class=&quot;modal-xxx&quot;&lt;/code&gt; anymore. I&amp;#8217;m talking about the modal itself. Because the semantic components will generate the corresponding &lt;code&gt;div&lt;/code&gt;. However using real components and not facets will allow you to put both bodyFacet and footerFacet inside a form for example.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com/component/tooltip/&quot;&gt;tooltip&lt;/a&gt; and &lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com/component/popover/&quot;&gt;popover&lt;/a&gt; are two new ways to display bonus info when the mouse moves over particular content. The first one is for small texts and labels only, the second one can support custom content and a title. Right now, content can only be text but we are planning to improve this.&lt;/p&gt;
&lt;div class=&quot;alert alert-info&quot;&gt;&lt;strong&gt;Pro tip&lt;/strong&gt; Even if &lt;strong&gt;popover&lt;/strong&gt; content only supports text, you can still put some light &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; in it. You just need to escape chevrons with &lt;code&gt;&amp;amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;amp;gt;&lt;/code&gt;.&lt;/div&gt;
&lt;p&gt;Finally, &lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com/component/orderingList/&quot;&gt;orderingList&lt;/a&gt; is the new RichFaces ordering list to allow you to re-arrange the order of some items. It already supports single drag-and-drop, multiple selection and &amp;#8220;table&amp;#8221; layout. Next features will be multiple drag-and-drop, maybe keyboard selection using &lt;span class=&quot;caps&quot;&gt;SHIFT&lt;/span&gt; (&lt;span class=&quot;caps&quot;&gt;CTRL&lt;/span&gt; is already supported). Thanks to Brian work, it is the first component mixing the power of the jQuery UI widget factory with Bootstrap design. If we can do it once, we can do it for lots of other widgets!&lt;/p&gt;
&lt;p&gt;New EL functions are also there. &lt;a href=&quot;https://github.com/richfaces/components/blob/develop/misc/ui/src/main/java/org/richfaces/function/RichFunction.java#L156&quot;&gt;jQuery&lt;/a&gt; and &lt;a href=&quot;https://github.com/richfaces/components/blob/develop/misc/ui/src/main/java/org/richfaces/function/RichFunction.java#L126&quot;&gt;jQuerySelector&lt;/a&gt; are part of RichFaces Core but have been created to help RichFaces Bootstrap. They will allow you to retrieve a jQuery object or the jQuery selector from a server-side &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; id.&lt;/p&gt;
&lt;p&gt;Next are more &lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com/component/el/&quot;&gt;specific Bootstrap EL functions&lt;/a&gt;. If you have take a look at Bootstrap JavaScript &lt;span class=&quot;caps&quot;&gt;API&lt;/span&gt;, you might have noticed that lots of JavaScript components have a set of functions with the following syntax: &lt;code&gt;$(sel).compName('singleParameter');&lt;/code&gt;, like for example: &lt;code&gt;$('#myModal').modal('show');&lt;/code&gt; for a &lt;strong&gt;modal&lt;/strong&gt;. The first approach to use it in &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; component was to use the previous &lt;strong&gt;jQuery&lt;/strong&gt; function like: &lt;code&gt;onclick=&quot;#{rich:jQuery( 'myModal' )}.modal('show')&quot;&lt;/code&gt;. It works fine but obviously, that wasn&amp;#8217;t enough for Lukas since he built a different approach from scratch.&lt;/p&gt;
&lt;p&gt;The new concept is that the &lt;code&gt;compName&lt;/code&gt; part of the call is nearly useless if you can retrieve it from the component returned from the jQuery call. In the previous example, if you know that &lt;code&gt;#{rich:jQuery('myModal')}&lt;/code&gt; is actually a &lt;strong&gt;modal&lt;/strong&gt; component, then you also know that you will have to call the &lt;strong&gt;modal&lt;/strong&gt; function, only remains with importance the &lt;strong&gt;singleParameter&lt;/strong&gt;. So here is the new syntax: &lt;code&gt;#{b:singleParameter(sel)}&lt;/code&gt;. The previous example becomes: &lt;code&gt;onclick=&quot;#{b:show('myModal')}&quot;&lt;/code&gt;. Much more concise and readable, isn&amp;#8217;t it? Right now, RichFaces Bootstrap supports &lt;strong&gt;show&lt;/strong&gt;, &lt;strong&gt;hide&lt;/strong&gt; and &lt;strong&gt;toggle&lt;/strong&gt; functions but others will follow soon.&lt;/p&gt;
&lt;div class=&quot;alert alert-info&quot;&gt;&lt;strong&gt;Pro tip&lt;/strong&gt; Want to know how the EL function retrieves the name of the component? Easy. When the selector will be used to find the &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; component, it will find a &lt;strong&gt;UIComponent&lt;/strong&gt; (like a &lt;strong&gt;UIModal&lt;/strong&gt;) which, according to RichFaces &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; design, will extend an &lt;strong&gt;AbstractComponent&lt;/strong&gt; (like &lt;a href=&quot;https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java&quot;&gt;AbstractModal&lt;/a&gt;). And if the &lt;strong&gt;AbstractComponent&lt;/strong&gt; supports Bootstrap EL functions, it will be annotated with &lt;code&gt;@BootstrapJSPlugin&lt;/code&gt; (like at &lt;a href=&quot;https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java#L43&quot;&gt;line 43 of AbstractModal&lt;/a&gt;) and it&amp;#8217;s the &lt;code&gt;name&lt;/code&gt; attribute of that annotation that will give us the &lt;code&gt;componentName&lt;/code&gt;. As I told you, really easy!&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;caps&quot;&gt;LESS&lt;/span&gt; support&lt;/strong&gt; is no longer a dream (for those who doesn&amp;#8217;t know &lt;span class=&quot;caps&quot;&gt;LESS&lt;/span&gt;, it&amp;#8217;s a more powerful way to write &lt;span class=&quot;caps&quot;&gt;CSS&lt;/span&gt;, see the &lt;a href=&quot;http://lesscss.org/&quot;&gt;project website&lt;/a&gt; for more infos). Thanks to Lukas&amp;#8217; awesome work, a first prototype of that feature is already working. You can &lt;a href=&quot;http://rik-ansikter.blogspot.fr/2012/08/jsf-meets-skinning-awesomeness-of-less.html&quot;&gt;read his post&lt;/a&gt; to know more about that. There is still work to do but it&amp;#8217;s an incredible starting point.&lt;/p&gt;
&lt;h3&gt;What&amp;#8217;s coming?&lt;/h3&gt;
&lt;p&gt;Want more? Great, because we have tons of other plans to improve RichFaces!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;New build design&lt;/strong&gt; is currently under &lt;a href=&quot;https://community.jboss.org/wiki/RichFaces43BuildRedesign&quot;&gt;discussion on RichFaces wiki&lt;/a&gt; so be sure to take a look and give feedback if you care about the future of RichFaces.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theming all current components&lt;/strong&gt; from RichFaces Core with Bootstrap design is planned so you can use both projects at the same time.&lt;/p&gt;
&lt;p&gt;The orderingList is just a beginning. &lt;strong&gt;More jQuery UI widget factory based components&lt;/strong&gt; are incoming. Feel free to comment &lt;a href=&quot;https://community.jboss.org/thread/200343&quot;&gt;here&lt;/a&gt; to propose the ones you would like to see supported in RichFaces Bootstrap.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;tab-pane&quot; id=&quot;2012-08-07-news-richfaces-bootstrap-fr&quot;&gt;
&lt;h3&gt;Quoi de neuf au sein de RichFaces Bootstrap ?&lt;/h3&gt;
&lt;div class=&quot;alert alert-error&quot;&gt;&lt;strong&gt;Alerte rouge !&lt;/strong&gt; Le projet RichFaces Bootstrap est encore en pleine phase de développement. Les noms des balises et de leurs attributs peuvent changer à tout moment et si vous trouvez un bug ou que quelque chose manque, il y a de fortes changes que cela n&amp;#8217;ait juste pas été encore fait (&amp;#8230; ou alors c&amp;#8217;est vraiment un bug). N&amp;#8217;utilisez ce projet qu&amp;#8217;à des fins de prototypage ou pour le plaisir.&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Les composants sémantiques&lt;/strong&gt; représentent un tout nouveau concept. Je me dois de les présenter en premier car j&amp;#8217;en aurais ensuite besoin quand je vous parlerai des nouveaux composants. La plupart du temps, pour un composant &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt;, vous avez un et un seul code &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; généré, il s&amp;#8217;agit d&amp;#8217;une relation oneToOne (si l&amp;#8217;on devait utiliser le vocabulaire de la norme &lt;span class=&quot;caps&quot;&gt;JPA&lt;/span&gt;). C&amp;#8217;est tout à fait logique : pour un composant, vous devriez toujours aboutir au même code &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; généré (à quelques détails de configuration prêt). Mais avec HTML5, le web devient un peu plus semantique et c&amp;#8217;est tant mieux. Alors pourquoi ne pas avoir la même chose dans RichFaces ? Mais avant d&amp;#8217;aller plus loin, qu&amp;#8217;est-ce qu&amp;#8217;être &amp;#8220;sémantique&amp;#8221; ? Pour une véritable définition, voyez &lt;a href=&quot;http://fr.wikipedia.org/wiki/Web_s%C3%A9mantique&quot;&gt;Wikipédia&lt;/a&gt; (la &lt;a href=&quot;http://en.wikipedia.org/wiki/Semantic_Web&quot;&gt;version anglaise&lt;/a&gt; est peut être préférable cela dit), mais dans notre cas, nous allons dire qu&amp;#8217;il s&amp;#8217;agit de composants qui ont une fonctionnalité globale, comme être un &amp;#8220;header&amp;#8221; ou un &amp;#8220;footer&amp;#8221;, et ne devraient pas toujours générer le même code &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; mais au contraire dépendre leur contexte (tout comme un &amp;#8220;header&amp;#8221; de table n&amp;#8217;est pas pareil qu&amp;#8217;un &amp;#8220;header&amp;#8221; de colonne).&lt;/p&gt;
&lt;p&gt;Dans RichFaces, un composant sémantique est un composant &lt;strong&gt;qui n&amp;#8217;a pas de renderer&lt;/strong&gt;! Oui oui, si vous utilisez un composant sémantique en solitaire, il vous lancera une exception à la figure car il ne sait pas quoi générer comme code &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; par lui même. Le concept est qu&amp;#8217;un composant sémantique doit demander à son composant parent dans l&amp;#8217;arbre &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; la question suivante : &amp;#8220;Hey papa, est-ce que tu sais quel code &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; je dois générer ?&amp;#8221; (ou bien &amp;#8220;Hey papa, est-ce que tu sais quel renderer je dois utiliser ?&amp;#8221;). Si le père connait la réponse, il devra fournir au composant sémantique le bon renderer, sinon, le composant sémantique devra reposer la question un niveau plus haut dans l&amp;#8217;arbre &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; et ainsi de suite jusqu&amp;#8217;à l&amp;#8217;élément racine. Si personne n&amp;#8217;a été capable de lui fournir une bonne réponse, et donc un renderer, il lancera une exception. Cela signifie bien sur qu&amp;#8217;il y a désormais des composants supportant les composants sémantiques.&lt;/p&gt;
&lt;p&gt;Assez de théorie, prenons un exemple concret ! Le composant &lt;strong&gt;modal&lt;/strong&gt; dans RichFaces Bootstrap supporte 3 composants sémantiques : un header, un body et un footer. On peut voir cela en regardant quelles interfaces sont implémentées par &lt;code&gt;AbstractModal&lt;/code&gt; (regardez &lt;a href=&quot;https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java#L49&quot;&gt;le code sur GitHub&lt;/a&gt;). Toutes les interfaces ayant une syntaxe de la forme &lt;code&gt;Render{1}Capable&lt;/code&gt; indiquent que notre composant supporte les composants sémantiques ayant pour nom &lt;code&gt;{1}&lt;/code&gt;, dans notre cas, &lt;strong&gt;headerFacet&lt;/strong&gt;, &lt;strong&gt;bodyFacet&lt;/strong&gt; et &lt;strong&gt;footerFacet&lt;/strong&gt;. Et si vous regardez plus en détail le code de &lt;code&gt;AbstractModal&lt;/code&gt;, vous verrez des méthodes ayant pour syntaxe &lt;code&gt;public String get{1}RendererType()&lt;/code&gt;. Il s&amp;#8217;agit des méthodes qui auront pour tâche de fournir le bon renderer aux composants sémantiques fils. Par exemple, dans le cadre du &lt;strong&gt;modal&lt;/strong&gt;, le composant sémantique &lt;strong&gt;headerFacet&lt;/strong&gt; génèrera un &lt;code&gt;div class&quot;=modal-header&quot;&lt;/code&gt; si l&amp;#8217;on en croit &lt;a href=&quot;https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/templates/org/richfaces/bootstrap/modalHeaderFacet.template.xml&quot;&gt;le renderer fournit&lt;/a&gt; par le &lt;strong&gt;modal&lt;/strong&gt;. Mais à l&amp;#8217;intérieur d&amp;#8217;un autre composant, cela aurait pu être un code &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; totalement différent.&lt;/p&gt;
&lt;div class=&quot;alert alert-info&quot;&gt;&lt;strong&gt;Pro tip&lt;/strong&gt; Si vous prenez le temps de regarder en détail tous les composants sémantiques, vous remarquerez qu&amp;#8217;ils suivent tous la même syntaxe : en premier leur fonction (comme &lt;strong&gt;header&lt;/strong&gt; ou &lt;strong&gt;footer&lt;/strong&gt;) et ensuite un suffixe commun &lt;strong&gt;Facet&lt;/strong&gt;. Cela nous donne la liste complète des actuels composants sémantiques : headerFacet, bodyFacet, footerFacet, menuFacet et footerFacet. Pourquoi utiliser un suffixe ? Tout d&amp;#8217;abord parce que nous souhaitons conserver le nom sans suffixe pour la véritable balise &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; correspondante. Le composant RichFaces &lt;strong&gt;header&lt;/strong&gt; devra toujours générer une balise &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; &lt;strong&gt;header&lt;/strong&gt; comme un composant &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; classique (la fameuse relation oneToOne) tandis que le composant &lt;strong&gt;headerFacet&lt;/strong&gt;, étant de nature sémantique, peut générer n&amp;#8217;importe quel code &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; dépendant de son contexte d&amp;#8217;utilisation. Ensuite parce que cela rend la vie plus facile pour savoir, rien qu&amp;#8217;à son nom, si un composant RichFaces est sémantique ou non.&lt;/div&gt;
&lt;div class=&quot;alert&quot;&gt;&lt;strong&gt;Attention&lt;/strong&gt; Même si le suffixe utilisé est &lt;strong&gt;Facet&lt;/strong&gt;, gardez bien à l&amp;#8217;esprit que les componsants sémantiques &lt;strong&gt;ne sont pas des facets&lt;/strong&gt; même s&amp;#8217;ils y ressemblent fortement dans l&amp;#8217;idée. Conséquence directe : ils n&amp;#8217;ont pas les mêmes limitations. Les composants sémantiques ont des attributs, peuvent avoir plusieurs fils et ne doivent pas forcément être un fils direct du composant parent les supportant. Vous pouvez également utiliser plusieurs fois le même composant sémantique dans un même composant parent.&lt;/div&gt;
&lt;p&gt;Passons maintenant aux nouveaux composants. Le composant &lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com/component/input/&quot;&gt;input&lt;/a&gt; est un input classique mais boosté avec les fonctionnalités de Bootstrap comme prepend et append, ainsi que de nouveaux attributs pour supporter les nouvelles fonctionnalités &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt;. Au passage, ce nouvel &lt;strong&gt;input&lt;/strong&gt; centralise et supporte tous les types d&amp;#8217;input en HTML5. Vous n&amp;#8217;aurez donc plus besoin d&amp;#8217;avoir un composant &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; par type d&amp;#8217;input, il vous suffira d&amp;#8217;utiliser l&amp;#8217;attribute &lt;code&gt;type&lt;/code&gt; (la valeur par défaut étant &amp;#8220;text&amp;#8221; bien entendu).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com/component/modal/&quot;&gt;modal&lt;/a&gt; est dans la même veine que &lt;code&gt;rich:modalPanel&lt;/code&gt; ou &lt;code&gt;rich:popupPanel&lt;/code&gt;. Il aura pour effet de faire apparaitre une fenêtre d&amp;#8217;alerte au dessus de votre page, couvrant potentiellement celle-ci d&amp;#8217;un filtre sombre pour empêcher toute action en dehors du modal. L&amp;#8217;usage par défaut est d&amp;#8217;avoir un header, spécifié en utilisant l&amp;#8217;attribut &lt;code&gt;header&lt;/code&gt; ou le facet &lt;code&gt;header&lt;/code&gt;, un footer, via le facet &lt;code&gt;footer&lt;/code&gt;, et un &lt;code&gt;body&lt;/code&gt; qui correspondra au contenu de la balise modal. Concrètement, ce qui se passe est que chaque partie, header &amp;#8211; body &amp;#8211; footer, va générer un &lt;code&gt;div class=&quot;modal-xxx&quot;&lt;/code&gt;, où &amp;#8220;xxx&amp;#8221; correspond à ladite partie, autour de son contenu afin de respecter la syntaxe de Bootstrap. Avoir le footer dans un facet peut être limitant car vous ne pouvez pas avoir &lt;strong&gt;un formulaire à l&amp;#8217;intérieur du modal&lt;/strong&gt; qui encapuselerait à la fois le body et le footer car le footer, en tant que facet, se retrouvera toujours à l&amp;#8217;extérieur. L&amp;#8217;usage recommandé est d&amp;#8217;avoir &lt;strong&gt;le modal entier à l&amp;#8217;intérieur du formulaire&lt;/strong&gt; compte tenu du fait que vous n&amp;#8217;aurez surement pas besoin d&amp;#8217;avoir plusieurs formulaires dans un même modal la plupart du temps.&lt;/p&gt;
&lt;p&gt;Mais que se passe-t-il si cela ne vous convient pas ? Si vous voulez vraiment le formulaire à l&amp;#8217;intérieur et non à l&amp;#8217;exérieur ? Même si le comportement par défaut décrit juste avant devrait être suffisant dans la grande majorité des cas, il est parfaitement compréhensible que dans certains cas, vous souhaitiez configurer votre modal de A à Z. Pour ce faire, il vous suffit d&amp;#8217;utiliser un des composants sémantiques suivant dans votre modal : headerFacet, bodyFacet, footerFacet. A partir du moment où l&amp;#8217;un d&amp;#8217;entre eux est détecté, le modal est considéré comme customisé et il ne génère plus de &lt;code&gt;div class=&quot;modal-xxx&lt;/code&gt; par lui même. Je parle bien du modal en personne, les composants sémantiques, eux, génèreront les &lt;code&gt;div&lt;/code&gt; correspondant à leur fonction. Cela vous permettra, par exemple, d&amp;#8217;avoir vos bodyFacet et footerFacet à l&amp;#8217;intérieur du même formulaire lui même à l&amp;#8217;intérieur du modal.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com/component/tooltip/&quot;&gt;tooltip&lt;/a&gt; et &lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com/component/popover/&quot;&gt;popover&lt;/a&gt; sont deux nouveaux moyens d&amp;#8217;afficher des informations supplémentaires lorsque la souris passe au dessus d&amp;#8217;un contenu en particulier. Le premier est plutôt orienté vers de courts textes ou des libellés tandis que le second peut posséder un contenu plus conséquent et même un titre. Pour le moment, le contenu en question ne peut être que du texte brut mais il est prévu d&amp;#8217;améliorer cela.&lt;/p&gt;
&lt;div class=&quot;alert alert-info&quot;&gt;&lt;strong&gt;Pro tip&lt;/strong&gt; Même si &lt;strong&gt;popover&lt;/strong&gt; ne supporte que du contenu textuel pour le moment, vous pouvez quand même utiliser un peu de &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; dedans. Il vous faudra juste écharper les chevrons en les remplaçant par &lt;code&gt;&amp;amp;lt;&lt;/code&gt; et &lt;code&gt;&amp;amp;gt;&lt;/code&gt;.&lt;/div&gt;
&lt;p&gt;Enfin, &lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com/component/orderingList/&quot;&gt;orderingList&lt;/a&gt; est la nouvelle version de RichFaces pour son composant oderingList et vous permet de réorganiser l&amp;#8217;ordre des éléments d&amp;#8217;une liste. Il supporte d&amp;#8217;ores et déjà le drag-and-drop (glisser-déposer) d&amp;#8217;un élément individuel, la sélection multiple et un design en forme de &amp;#8220;table&amp;#8221;. Les fonctionnalités à venir sont le drap-and-drop de plusieurs éléments à la fois et peut être la sélection en utilisant la touche &lt;span class=&quot;caps&quot;&gt;SHIFT&lt;/span&gt; du clavier (&lt;span class=&quot;caps&quot;&gt;CTRL&lt;/span&gt; est déjà supporté). Grâce au travail de Brian, il s&amp;#8217;agit du tout premier composant utilisant à la fois la puissance de jQuery UI widget factory avec un design Bootstrap. Si nous pouvons le faire une fois, alors nous pouvons également le faire pour bien d&amp;#8217;autres widgets jQuery.&lt;/p&gt;
&lt;p&gt;De nouvelles fonctions EL sont également de la partie. &lt;a href=&quot;https://github.com/richfaces/components/blob/develop/misc/ui/src/main/java/org/richfaces/function/RichFunction.java#L156&quot;&gt;jQuery&lt;/a&gt; et &lt;a href=&quot;https://github.com/richfaces/components/blob/develop/misc/ui/src/main/java/org/richfaces/function/RichFunction.java#L126&quot;&gt;jQuerySelector&lt;/a&gt; se trouvent directement dans RichFaces Core mais ont été créées avant tout dans l&amp;#8217;optique d&amp;#8217;être utilisées dans RichFaces Bootstrap. Elles vous permettent de récupérer un objet jQuery ou un sélecteur jQuery à partir de l&amp;#8217;id &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; côté serveur.&lt;/p&gt;
&lt;p&gt;Ensuite viennent des &lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com/component/el/&quot;&gt;fonctions EL spécifiques à Bootstrap&lt;/a&gt;. Si vous regardez l&amp;#8217;API JavaScript de Bootstrap, vous noterez que nombre de composants JavaScript possèdent une liste de fonctions avec la syntaxe suivante : &lt;code&gt;$(sel).nomDuComposant('paramUnique');&lt;/code&gt;, comme par exemple : &lt;code&gt;$('#monModal').modal('show');&lt;/code&gt; pour un &lt;strong&gt;modal&lt;/strong&gt;. La première approche pour les utiliser dans une page &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; est de de servir de la fonction &lt;strong&gt;jQuery&lt;/strong&gt; vue précédemment de la manière suivante : &lt;code&gt;onclick=&quot;#{rich:jQuery( 'monModal' )}.modal('show')&quot;&lt;/code&gt;. Cela fonctionne à merveille mais ce n&amp;#8217;était visiblement pas suffisant pour Lukas qui s&amp;#8217;est offert le luxe de coder depuis zéro une autre approche.&lt;/p&gt;
&lt;p&gt;Le nouveau concept vient du fait que la partie &lt;code&gt;nomComp&lt;/code&gt; est inutile si vous pouvez récupérer ledit nom depuis le composant retourné par l&amp;#8217;appel à jQuery. Dans l&amp;#8217;exemple précédent, si l&amp;#8217;on sait que &lt;code&gt;#{rich:jQuery('monModal')}&lt;/code&gt; va retourner un &lt;strong&gt;modal&lt;/strong&gt; alors on sait également que c&amp;#8217;est la fonction &lt;strong&gt;modal&lt;/strong&gt; qu&amp;#8217;il faudra appeler, si bien que la seule inconnue restante est le &lt;strong&gt;paramUnique&lt;/strong&gt;. Voici donc la nouvelle syntaxe : &lt;code&gt;#{b:paramUnique(sel)}&lt;/code&gt;. L&amp;#8217;exemple précédent devient : &lt;code&gt;onclick=&quot;#{b:show('monModal')}&quot;&lt;/code&gt;. Bien moins verbeux et bien plus lisible n&amp;#8217;est-ce pas ? A l&amp;#8217;heure actuelle, RichFaces Bootstrap possède les fonctions &lt;strong&gt;show&lt;/strong&gt;, &lt;strong&gt;hide&lt;/strong&gt; et &lt;strong&gt;toggle&lt;/strong&gt; mais d&amp;#8217;autres suivront bientôt.&lt;/p&gt;
&lt;div class=&quot;alert alert-info&quot;&gt;&lt;strong&gt;Pro tip&lt;/strong&gt; Envie de savoir comment la fonction EL récupère le nom du composant ? Facile. Quand le sélecteur est utilisé pour récupérer le composant &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt;, il va retourner un &lt;strong&gt;UIComponent&lt;/strong&gt; (par exemple un &lt;strong&gt;UIModal&lt;/strong&gt;) qui, en accord avec la syntaxe du &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; RichFaces, devra étendre un &lt;strong&gt;AbstractComponent&lt;/strong&gt; (comme &lt;a href=&quot;https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java&quot;&gt;AbstractModal&lt;/a&gt;). Et si cet &lt;strong&gt;AbstractComponent&lt;/strong&gt; supporte les fonctions EL spécifiques à Bootstrap, alors il sera annoté de &lt;code&gt;@BootstrapJSPlugin&lt;/code&gt; (comme on peut le voir à &lt;a href=&quot;https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java#L43&quot;&gt;la ligne 43 de AbstractModal&lt;/a&gt;) et c&amp;#8217;est l&amp;#8217;attribute &lt;code&gt;name&lt;/code&gt; de l&amp;#8217;annotation qui nous fournit le &lt;code&gt;nomDuComposant&lt;/code&gt;. Comme je vous l&amp;#8217;avais dit, super facile !&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Le support de &lt;span class=&quot;caps&quot;&gt;LESS&lt;/span&gt;&lt;/strong&gt; n&amp;#8217;est plus un rêve mais désormais une réalité (pour ceux qui ne connaissent pas &lt;span class=&quot;caps&quot;&gt;LESS&lt;/span&gt;, il s&amp;#8217;agit d&amp;#8217;une syntaxe permettant d&amp;#8217;écrire du &lt;span class=&quot;caps&quot;&gt;CSS&lt;/span&gt; de manière bien plus puissante et élégante, je vous encourage à consulter le &lt;a href=&quot;http://lesscss.org/&quot;&gt;site du projet&lt;/a&gt; pour de plus amples informations). Grâce au travail incroyable de Lukas, un premier prototype est déjà fonctionnel. N&amp;#8217;hésitez pas à &lt;a href=&quot;http://rik-ansikter.blogspot.fr/2012/08/jsf-meets-skinning-awesomeness-of-less.html&quot;&gt;lire son article&lt;/a&gt; à ce sujet pour en savoir plus (anglais uniquement). Il y a encore du travail à faire, mais il s&amp;#8217;agit un bon point de départ.&lt;/p&gt;
&lt;h3&gt;Qu&amp;#8217;avons nous en approche ?&lt;/h3&gt;
&lt;p&gt;Vous en voulez encore ? Tant mieux car nous avons de nombreuses idées pour améliorer RichFaces !&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Un nouveau modèle de build&lt;/strong&gt; est en cours de &lt;a href=&quot;https://community.jboss.org/wiki/RichFaces43BuildRedesign&quot;&gt;discussion sur le wiki RichFaces&lt;/a&gt;. Je vous encourage vivement à prendre le temps de le lire (en anglais uniquement) et de donner votre avis si vous vous sentez concerné par l&amp;#8217;avenir de RichFaces.&lt;/p&gt;
&lt;p&gt;Il est prévu de fournir &lt;strong&gt;un nouveau design à tous les composants&lt;/strong&gt; de RichFaces Core à partir du design de Bootstrap pour que vous puissez utiliser les deux projets en même temps.&lt;/p&gt;
&lt;p&gt;Le composant orderingList n&amp;#8217;est que le commencement. &lt;strong&gt;D&amp;#8217;autres composants basés sur jQuery UI widget factory&lt;/strong&gt; sont en approche. N&amp;#8217;hésitez pas à &lt;a href=&quot;https://community.jboss.org/thread/200343&quot;&gt;poster ici&lt;/a&gt; pour proposer des widgets que vous aimeriez voir dans RichFaces Bootstrap.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
    </content>
  </entry>
  <entry>
    <id>http://pauldijou.fr/blog/2012/08/01/news-richfaces-cdk.html</id>
    <title>News about RichFaces CDK</title>
    <updated>2012-08-01T00:00:00Z</updated>
    <published>2012-08-01T00:00:00Z</published>
    <link href='http://pauldijou.fr/blog/2012/08/01/news-richfaces-cdk.html' rel='alternate' type='text/html' />
    <summary>
      Table of Content

	English version
	Version Francaise

RichFaces CDK new features
As the RichFaces Bootstrap project grows, we need more tools to achieve new goals and keep the code clean and readable. More tools means a stronger CDK and here are the last features.
Fragments are small portions of code inside the template that are defined outside of the main implementation but can be called inside it or inside other fragments or even inside itself! Say hello to recursion in RichFaces CDK templates. In term of Java, fragments are methods. So when you write a fragment, it will generates a Java method in the final...
    </summary>
    <content type='html'>
      &lt;h3&gt;Table of Content&lt;/h3&gt;
&lt;ol&gt;
	&lt;li&gt;&lt;a href=&quot;#news-richfaces-cdk-en&quot;&gt;English version&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;#news-richfaces-cdk-fr&quot;&gt;Version Francaise&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;news-richfaces-cdk-en&quot;&gt;RichFaces &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; new features&lt;/h3&gt;
&lt;p&gt;As the RichFaces Bootstrap project grows, we need more tools to achieve new goals and keep the code clean and readable. More tools means a stronger &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; and here are the last features.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fragments&lt;/strong&gt; are small portions of code inside the template that are defined outside of the main implementation but can be called inside it or inside other fragments or even inside itself! Say hello to recursion in RichFaces &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; templates. In term of Java, fragments are methods. So when you write a fragment, it will generates a Java method in the final renderer. Knowing that makes fragments really easy to understand and to use. See the &lt;a href=&quot;https://issues.jboss.org/browse/RF-12226&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12226&lt;/a&gt; for a fully explained example.&lt;/p&gt;
&lt;div class=&quot;alert alert-info&quot;&gt;&lt;strong&gt;Pro tip&lt;/strong&gt; Notice that in the signature of the generated Java method, 3 arguments are always passed without having to specify them inside the template : ResponseWriter, FacesContext and UIComponent.&lt;/div&gt;
&lt;div class=&quot;alert&quot;&gt;&lt;strong&gt;Warning&lt;/strong&gt; Currently, if you want to use a fragment1 inside a fragment2, you need to write fragment1 first in your template so its signature has been parsed before calling it in fragment2. Problem is reported in &lt;a href=&quot;https://issues.jboss.org/browse/RF-12326&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12326&lt;/a&gt;.&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;cc:renderFacet&lt;/strong&gt; is a new tag you can use inside a &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; template, equivalent of the same tag from &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; composite component. Its usage is quite straightforward: it will render the facet that you will specify in the &lt;code&gt;name&lt;/code&gt; attribute. If you put some content inside the tag, it will be used as default value in case the facet is missing. See &lt;a href=&quot;https://issues.jboss.org/browse/RF-12260&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12260&lt;/a&gt; for full description.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;varStatus&lt;/strong&gt; is a new attribute for the &lt;strong&gt;c:forEach&lt;/strong&gt; &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; tag. It will perform the exact same thing as the one in the original &lt;strong&gt;c:forEach&lt;/strong&gt; tag, giving you more tools inside a forEach loop. See &lt;a href=&quot;https://issues.jboss.org/browse/RF-12232&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12232&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wildcard&lt;/strong&gt; can now be used inside &lt;strong&gt;cdk:passThrough&lt;/strong&gt; and &lt;strong&gt;cdk:passThroughWithExclusions&lt;/strong&gt; attributes in order to pass all attributes starting with the same prefix. Especially useful with JavaScript events &lt;code&gt;on*&lt;/code&gt;. Wildcard can be use with attribute mapping like &lt;code&gt;onkey*:oninputkey*&lt;/code&gt;. See &lt;a href=&quot;https://issues.jboss.org/browse/RF-12200&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12200&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;component&lt;/strong&gt; variable is now directly casted to the correct class based on &lt;code&gt;cdk:class&lt;/code&gt; tag in the template. You will no longer need to write explicitly the cast inside 95% of your templates. Enjoy less verbose code and see &lt;a href=&quot;https://issues.jboss.org/browse/RF-12248&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12248&lt;/a&gt; for more details.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;In general&lt;/strong&gt;, &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; has been improved to be more type-safe which allows to catch more issues at compilte-time.&lt;/p&gt;
&lt;h3&gt;What&amp;#8217;s next?&lt;/h3&gt;
&lt;p&gt;There are still a few points undone in the &lt;a href=&quot;https://community.jboss.org/wiki/CDKWish-List&quot;&gt;&lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; wish-list&lt;/a&gt; and I hope some of them will be realized. One of the most important is probably generating methods from interfaces! See &lt;a href=&quot;https://issues.jboss.org/browse/RF-12339&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12339&lt;/a&gt; to fully understand the concept.&lt;/p&gt;
&lt;p&gt;In another topic, another post will follow next week to talk about what&amp;#8217;s new in &lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com&quot;&gt;RichFaces Bootstrap project&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;news-richfaces-cdk-fr&quot;&gt;Les nouvelles fonctionnalités du &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; RichFaces&lt;/h3&gt;
&lt;p&gt;En même temps que le projet RichFaces Boostrap grandit, le besoin de nouveaux outils pour garder le code propre et lisible se fait sentir. De nouveaux outils signifie un &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; plus puissant et voici les dernières fonctionnalités ajoutées.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Les fragments&lt;/strong&gt; sont de petites portions de code que vous définissez au sein de votre template, à l&amp;#8217;extérieur de l&amp;#8217;implémentation principale, mais ils peuvent être appelé au sein de celle-ci, ou à l&amp;#8217;intérieur d&amp;#8217;autres fragments, ou au sein d&amp;#8217;eux même ! Dites bonjour à la récursivité dans les templates du &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; RichFaces. Côté Java, les fragments sont purement et simplement des méthodes. Cela signifie que chaque fois que vous écrivez un fragment dans un template, cela aura pour effet de générer une méthode Java dans le renderer final. En sachant cela, il devient relativement aisé de comprendre et maitriser les fragments. N&amp;#8217;hésitez pas à lire &lt;a href=&quot;https://issues.jboss.org/browse/RF-12226&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12226&lt;/a&gt; pour un exemple détaillé.&lt;/p&gt;
&lt;div class=&quot;alert alert-info&quot;&gt;&lt;strong&gt;Pro tip&lt;/strong&gt; Vous remarquerez que la signature de la méthode Java générée comporte 3 paramètres qui sont toujours présents et que vous n&amp;#8217;avez jamais à spécifier dans le template. Il s&amp;#8217;agit de ResponserWriter, FacesContext et UIComponent.&lt;/div&gt;
&lt;div class=&quot;alert&quot;&gt;&lt;strong&gt;Attention&lt;/strong&gt; Actuellement, si vous voulez utiliser un fragment1 à l&amp;#8217;intérieur d&amp;#8217;un fragment2, vous devez écrire fragment1 en premier dans votre template afin que sa signature ait été parsée avant d&amp;#8217;être appelée dans fragment2. Le problème a été reporté dans &lt;a href=&quot;https://issues.jboss.org/browse/RF-12326&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12326&lt;/a&gt;.&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;cc:renderFacet&lt;/strong&gt; est une nouvelle balise que vous pouvez utiliser dans les templates &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; et qui équivaut à la balise du même nom dans les composants composites de &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt;. Son usage est assez évident : elle va générer le facet que vous aurez spécifié via l&amp;#8217;attribut &lt;code&gt;name&lt;/code&gt;. Si vous spécifiez un contenu dans la balise, celui-ci sera utilisé comme valeur par défaut si jamais le facet était absent. Voyez &lt;a href=&quot;https://issues.jboss.org/browse/RF-12260&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12260&lt;/a&gt; pour une description complète.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;varStatus&lt;/strong&gt; est un nouvel attribut de la balise &lt;strong&gt;c:forEach&lt;/strong&gt; du &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt;. Il a les mêmes effets que celui de la balise originale &lt;strong&gt;c:forEach&lt;/strong&gt;, vous donnant accès à des nouveaux outils à l&amp;#8217;intérieur d&amp;#8217;une boucle forEach. Voyez &lt;a href=&quot;https://issues.jboss.org/browse/RF-12232&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12232&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Les &amp;#8220;wildcards&amp;#8221;&lt;/strong&gt; (= astérisques) peuvent désormais être utilisées dans les attributes &lt;strong&gt;cdk:passThrough&lt;/strong&gt; et &lt;strong&gt;cdk:passThroughWithExclusions&lt;/strong&gt; afin de passer directement tous les attributes commençant avec le même préfixe. Particulièrement utile pour les évènements JavaScript &lt;code&gt;on*&lt;/code&gt;. Les wildcards peuvent bien sur être utilisées dans le cadre d&amp;#8217;un mapping comme &lt;code&gt;onkey*:oninputkey*&lt;/code&gt;. Voyez &lt;a href=&quot;https://issues.jboss.org/browse/RF-12200&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12200&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;La variable &lt;strong&gt;component&lt;/strong&gt; au sein des templates est maintenant automatiquement castée dans le bon type en se basant sur la balise &lt;code&gt;cdk:class&lt;/code&gt; du template. Vous n&amp;#8217;aurez plus besoin d&amp;#8217;écrire explicitement ce cast dans 95% de vos templates. Vous apprécierez ainsi un code moins verbeux. Jetez un oeil à &lt;a href=&quot;https://issues.jboss.org/browse/RF-12248&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12248&lt;/a&gt; pour plus de détails.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;De manière générale&lt;/strong&gt;, le &lt;span class=&quot;caps&quot;&gt;CDK&lt;/span&gt; a été amélioré pour être encore plus type-safe et ainsi pouvoir détecter d&amp;#8217;éventuels problèmes à la compilation.&lt;/p&gt;
&lt;h3&gt;Et ensuite ?&lt;/h3&gt;
&lt;p&gt;La &lt;a href=&quot;https://community.jboss.org/wiki/CDKWish-List&quot;&gt;liste des souhaits à réaliser&lt;/a&gt; n&amp;#8217;a pas encore été intégralement réalisée et j&amp;#8217;espère que certains le seront très bientôt. L&amp;#8217;un des plus importants est probablement la génération de méthodes dans les renderer ou les composants à partir de nouvelles interfaces qu&amp;#8217;ils étendraient. &lt;a href=&quot;https://issues.jboss.org/browse/RF-12339&quot;&gt;&lt;span class=&quot;caps&quot;&gt;JIRA&lt;/span&gt; issue 12339&lt;/a&gt; décrit le concept dans son intégralité.&lt;/p&gt;
&lt;p&gt;Dans un autre registre, un autre post suivra la semaine prochaine pour vous parler des nouveautés du projet &lt;a href=&quot;http://bootstrap-richfaces.rhcloud.com&quot;&gt;RichFaces Bootstrap&lt;/a&gt;.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>http://pauldijou.fr/blog/2012/05/08/jsf-bootstrap-render-all.html</id>
    <title>JSF, Bootstrap and calling render=@all</title>
    <updated>2012-05-08T00:00:00Z</updated>
    <published>2012-05-08T00:00:00Z</published>
    <link href='http://pauldijou.fr/blog/2012/05/08/jsf-bootstrap-render-all.html' rel='alternate' type='text/html' />
    <summary>
      The problem
      So, the other day, I was playing with Twitter Bootstrap on a JSF application. Everything was fine until I decide to use a render="@all" somewhere in the page in order to refresh all my components after quite an heavy operation. Working fine.
      But Bootstrap was no longuer fully healthy. The CSS and design were ok, but the Javascript was all broken : nearly all effects didn&#8217;t appear anymore. It was a bit strange so I hit F5 and everything was fine, all Javascript events were back. But the moment my render="@all" was called, they dissapear again.
      Why?
      After some investigations, the reason...
    </summary>
    <content type='html'>
      &lt;h3&gt;The problem&lt;/h3&gt;
&lt;p&gt;So, the other day, I was playing with &lt;a href=&quot;http://twitter.github.com/bootstrap/index.html&quot;&gt;Twitter Bootstrap&lt;/a&gt; on a &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; application. Everything was fine until I decide to use a &lt;code&gt;render=&quot;@all&quot;&lt;/code&gt; somewhere in the page in order to refresh all my components after quite an heavy operation. Working fine.&lt;/p&gt;
&lt;p&gt;But Bootstrap was no longuer fully healthy. The &lt;span class=&quot;caps&quot;&gt;CSS&lt;/span&gt; and design were ok, but the Javascript was all broken : nearly all effects didn&amp;#8217;t appear anymore. It was a bit strange so I hit F5 and everything was fine, all Javascript events were back. But the moment my &lt;code&gt;render=&quot;@all&quot;&lt;/code&gt; was called, they dissapear again.&lt;/p&gt;
&lt;h3&gt;Why?&lt;/h3&gt;
&lt;p&gt;After some investigations, the reason was that Bootstrap calls a Javascript function that will attach most of its events to the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; when the &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; &lt;span class=&quot;caps&quot;&gt;DOM&lt;/span&gt; is ready. Its doing so in order to catch all user interactions when they bubble up to the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag which wrap the whole page. With that, you can use Ajax as much as you want and update your &lt;span class=&quot;caps&quot;&gt;DOM&lt;/span&gt; since there is no event attach to a particular &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; tag, they are all in the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag.&lt;/p&gt;
&lt;p&gt;That&amp;#8217;s really good but that&amp;#8217;s also the reason of the problem. I said Ajax is always fine, and it&amp;#8217;s true as long as you don&amp;#8217;t touch the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag. The moment you update this tag, it will probably be reset to it&amp;#8217;s initial state, without any Javascript event, and since the Bootstrap Javascript function is only called once when the &lt;span class=&quot;caps&quot;&gt;DOM&lt;/span&gt; is ready the first time, Javascript events will not come back. Guess what, &lt;code&gt;render=&quot;@all&quot;&lt;/code&gt; will render your &lt;code&gt;&amp;lt;h:body&amp;gt;&lt;/code&gt; and so will broke all Bootstrap Javascipt events.&lt;/p&gt;
&lt;h3&gt;A workaround&lt;/h3&gt;
&lt;p&gt;The true solution would be to call the Bootstrap Javascript function after each &lt;code&gt;render=&quot;@all&quot;&lt;/code&gt; in order to attach all Javascript events again. But since I have no idea how to do that right now, I have choosen to use an easier workaround.&lt;/p&gt;
&lt;p&gt;Just wrapping your whole page in a &lt;span class=&quot;caps&quot;&gt;JSF&lt;/span&gt; panel and render it instead of &lt;code&gt;render=&quot;@all&quot;&lt;/code&gt; should be enough in most use case. It is not exactly the same behaviour, but in most case, when calling &lt;code&gt;render=&quot;@all&quot;&lt;/code&gt;, what you really want is just refreshing your whole page using Ajax. For example:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;#x000A;&amp;lt;html lang=&quot;en-US&quot;&amp;#x000A;      xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;#x000A;      xmlns:h=&quot;http://java.sun.com/jsf/html&quot;&amp;#x000A;      xmlns:f=&quot;http://java.sun.com/jsf/core&quot;&amp;#x000A;      xmlns:ui=&quot;http://java.sun.com/jsf/facelets&quot;&amp;gt;&amp;#x000A;&amp;lt;h:head&amp;gt;&amp;#x000A;    &amp;lt;title&amp;gt;Site title&amp;lt;/title&amp;gt;&amp;#x000A;&amp;lt;/h:head&amp;gt;&amp;#x000A;&amp;lt;h:body&amp;gt;&amp;#x000A;    &amp;lt;h:panelGroup id=&quot;all&quot;&amp;gt;&amp;#x000A;        ... your code...&amp;#x000A;    &amp;lt;/h:panelGroup&amp;gt;&amp;#x000A;&amp;lt;/h:body&amp;gt;&amp;#x000A;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And replace all your &lt;code&gt;render=&quot;@all&quot;&lt;/code&gt; with &lt;code&gt;render=&quot;all&quot;&lt;/code&gt;.&lt;/p&gt;
    </content>
  </entry>
</feed>
